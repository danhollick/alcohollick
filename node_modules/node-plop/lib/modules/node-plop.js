'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _inquirer = require('inquirer');

var _inquirer2 = _interopRequireDefault(_inquirer);

var _handlebars = require('handlebars');

var _handlebars2 = _interopRequireDefault(_handlebars);

var _bakedInHelpers = require('./baked-in-helpers');

var _bakedInHelpers2 = _interopRequireDefault(_bakedInHelpers);

var _generatorRunner = require('./generator-runner');

var _generatorRunner2 = _interopRequireDefault(_generatorRunner);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function nodePlop() {
	let plopfilePath = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
	let plopCfg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};


	var pkgJson = {};
	var defaultInclude = { generators: true };

	const destBasePath = plopCfg.destBasePath;

	const generators = {};
	const partials = {};
	const helpers = Object.assign({
		pkg: key => pkgJson[key] || ''
	}, _bakedInHelpers2.default);
	const baseHelpers = Object.keys(helpers);

	const addPrompt = _inquirer2.default.registerPrompt;
	const addHelper = (name, fn) => {
		helpers[name] = fn;
	};
	const addPartial = (name, str) => {
		partials[name] = str;
	};

	function renderString(template, data) {
		Object.keys(helpers).forEach(h => _handlebars2.default.registerHelper(h, helpers[h]));
		Object.keys(partials).forEach(p => _handlebars2.default.registerPartial(p, partials[p]));
		return _handlebars2.default.compile(template)(data);
	}

	const getHelper = name => helpers[name];
	const getPartial = name => partials[name];
	const getGenerator = name => generators[name];
	function setGenerator() {
		let name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
		let config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

		// if no name is provided, use a default
		name = name || `generator-${ Object.keys(generators).length + 1 }`;

		// add the generator to this context
		generators[name] = Object.assign(config, {
			name: name,
			basePath: plopfilePath
		});

		return generators[name];
	}

	const getHelperList = () => Object.keys(helpers).filter(h => !baseHelpers.includes(h));
	const getPartialList = () => Object.keys(partials);
	function getGeneratorList() {
		return Object.keys(generators).map(function (name) {
			const description = generators[name].description;

			return { name: name, description: description };
		});
	}

	const setDefaultInclude = inc => defaultInclude = inc;
	const getDefaultInclude = () => defaultInclude;
	const getDestBasePath = () => destBasePath || plopfilePath;
	const getPlopfilePath = () => plopfilePath;
	const setPlopfilePath = filePath => plopfilePath = _path2.default.dirname(filePath);

	function load(targets) {
		let loadCfg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
		let includeOverride = arguments[2];

		if (typeof targets === 'string') {
			targets = [targets];
		}
		const config = Object.assign({
			destBasePath: getDestBasePath()
		}, loadCfg);

		targets.forEach(function (target) {
			var targetPath;

			try {
				targetPath = require.resolve(target);
			} catch (err) {
				targetPath = _path2.default.resolve(getPlopfilePath(), target);
			}

			const proxy = nodePlop(targetPath, config);
			const proxyDefaultInclude = proxy.getDefaultInclude() || {};
			const includeCfg = includeOverride || proxyDefaultInclude;
			const include = Object.assign({
				generators: false,
				helpers: false,
				partials: false
			}, includeCfg);

			const genNameList = proxy.getGeneratorList().map(g => g.name);
			loadAsset(genNameList, include.generators, setGenerator, proxyName => ({ proxyName: proxyName, proxy: proxy }));
			loadAsset(proxy.getPartialList(), include.partials, addPartial, proxy.getPartial);
			loadAsset(proxy.getHelperList(), include.helpers, addHelper, proxy.getHelper);
		});
	}

	function loadAsset(nameList, include, addFunc, getFunc) {
		var incArr;
		if (include === true) {
			incArr = nameList;
		}
		if (include instanceof Array) {
			incArr = include.filter(n => typeof n === 'string');
		}
		if (incArr != null) {
			include = incArr.reduce(function (inc, name) {
				inc[name] = name;
				return inc;
			}, {});
		}

		if (include instanceof Object) {
			Object.keys(include).forEach(i => addFunc(include[i], getFunc(i)));
		}
	}

	function loadPackageJson() {
		// look for a package.json file to use for the "pkg" helper
		try {
			pkgJson = require(_path2.default.join(getDestBasePath(), 'package.json'));
		} catch (error) {
			pkgJson = {};
		}
	}

	/////////
	// the plop object API that is exposed to the plopfile when executed
	// it differs from the nodePlopApi in that it does not include the
	// generator runner methods
	//
	const plopApi = {
		addHelper: addHelper, addPartial: addPartial, addPrompt: addPrompt, renderString: renderString,
		setGenerator: setGenerator, getGenerator: getGenerator, getGeneratorList: getGeneratorList,
		setPlopfilePath: setPlopfilePath, getPlopfilePath: getPlopfilePath, getDestBasePath: getDestBasePath, load: load,
		setDefaultInclude: setDefaultInclude,
		inquirer: _inquirer2.default, handlebars: _handlebars2.default
	};

	// the runner for this instance of the nodePlop api
	const runner = (0, _generatorRunner2.default)(plopApi);
	const nodePlopApi = Object.assign({}, plopApi, {
		getGenerator: function getGenerator(name) {
			var generator = plopApi.getGenerator(name);

			// if this generator was loaded from an external plopfile, proxy the
			// generator request through to the external plop instance
			if (generator.proxy) {
				return generator.proxy.getGenerator(generator.proxyName);
			}

			return Object.assign({}, generator, {
				runActions: data => runner.runGeneratorActions(generator, data),
				runPrompts: () => runner.runGeneratorPrompts(generator)
			});
		},
		setGenerator: function setGenerator(name, config) {
			const g = plopApi.setGenerator(name, config);
			return this.getGenerator(g.name);
		},

		getPartialList: getPartialList, getPartial: getPartial,
		getHelperList: getHelperList, getHelper: getHelper,
		getDefaultInclude: getDefaultInclude
	});

	if (plopfilePath) {
		plopfilePath = _path2.default.resolve(plopfilePath);
		const plopFileName = _path2.default.basename(plopfilePath);
		setPlopfilePath(plopfilePath);
		loadPackageJson();

		require(_path2.default.join(plopfilePath, plopFileName))(plopApi, plopCfg);
	} else {
		setPlopfilePath(process.cwd());
		loadPackageJson();
	}

	return nodePlopApi;
}

exports.default = nodePlop;