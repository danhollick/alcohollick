'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

exports.default = function (plop) {
	if (plop.proxy != null) {
		plop = plop.proxy;
	}
	var abort;

	// if not already an absolute path, make an absolute path from the basePath (plopfile location)
	const makeTmplPath = p => _path2.default.resolve(plop.getPlopfilePath(), p);
	const makeDestPath = p => _path2.default.resolve(plop.getDestBasePath(), p);

	// triggers inquirer with the correct prompts for this generator
	// returns a promise that resolves with the user's answers
	const runGeneratorPrompts = _co2.default.wrap(function* (genObject) {
		if (genObject.prompts == null) {
			throw Error(`${ genObject.name } does no have prompts.`);
		}
		return yield plop.inquirer.prompt(genObject.prompts);
	});

	// Run the actions for this generator
	const runGeneratorActions = _co2.default.wrap(function* (genObject, data) {
		var changes = []; // array of changed made by the actions
		var failures = []; // array of actions that failed
		var actions = genObject.actions; // the list of actions to execute

		abort = false;

		// if action is a function, run it to get our array of actions
		if (typeof actions === 'function') {
			actions = actions(data);
		}

		// if actions are not defined... we cannot proceed.
		if (actions == null) {
			throw Error(`${ genObject.name } does no have actions.`);
		}

		// if actions are not an array, invalid!
		if (!(actions instanceof Array)) {
			throw Error(`${ genObject.name } does has invalid actions.`);
		}

		for (let action of actions) {
			// bail out if a previous action aborted
			if (abort) {
				failures.push({
					type: action.type || '',
					path: action.path || '',
					error: 'Aborted due to previous action failure'
				});
				continue;
			}

			const actionInterfaceTest = testActionInterface(action);
			if (actionInterfaceTest !== true) {
				failures.push(actionInterfaceTest);
				continue;
			}

			try {
				let result;
				if (typeof action === 'function') {
					result = yield executeCustomAction(action, data);
				} else {
					result = yield executeAction(action, data);
				}
				changes.push(result);
			} catch (failure) {
				failures.push(failure);
			}
		}

		return { changes: changes, failures: failures };
	});

	/////
	// action handlers
	//

	// custom action functions
	const executeCustomAction = _co2.default.wrap(function* (action, data) {
		const failure = makeErrorLogger(action.type || 'function', '', action.abortOnFail);

		// convert any returned data into a promise to
		// return and wait on
		return yield Promise.resolve(action(data)).then(
		// show the resolved value in the console
		result => ({
			type: action.type || 'function',
			path: _colors2.default.blue(result.toString())
		}),
		// a rejected promise is treated as a failure
		function (err) {
			throw failure(err.message || err.toString());
		});
	});

	// basic function objects
	const executeAction = _co2.default.wrap(function* (action, data) {
		var template = action.template;

		const fileDestPath = makeDestPath(plop.renderString(action.path || '', data));
		const failure = makeErrorLogger(action.type, fileDestPath, action.abortOnFail);

		try {
			if (action.templateFile) {
				template = yield fspp.readFile(makeTmplPath(action.templateFile));
			}
			if (template == null) {
				template = '';
			}

			// check path
			const pathExists = yield fspp.fileExists(fileDestPath);

			// handle type
			if (action.type === 'add') {
				if (pathExists) {
					throw failure('File already exists');
				} else {
					yield fspp.makeDir(_path2.default.dirname(fileDestPath));
					yield fspp.writeFile(fileDestPath, plop.renderString(template, data));
				}
			} else if (action.type === 'modify') {
				if (!pathExists) {
					throw failure('File does not exists');
				} else {
					var fileData = yield fspp.readFile(fileDestPath);
					fileData = fileData.replace(action.pattern, plop.renderString(template, data));
					yield fspp.writeFile(fileDestPath, fileData);
				}
			} else {
				throw failure(`Invalid action type: ${ action.type }`);
			}

			return {
				type: action.type,
				path: fileDestPath
			};
		} catch (err) {
			throw failure(err.error || err.message || JSON.stringify(err));
		}
	});

	function testActionInterface(action) {
		// action functions are valid, end of story
		if (typeof action === 'function') {
			return true;
		}

		// it's not even an object, you fail!
		if (typeof action !== 'object') {
			return { type: '', path: '', error: `Invalid action object: ${ JSON.stringify(action) }` };
		}

		var type = action.type,
		    path = action.path,
		    abortOnFail = action.abortOnFail;

		const failure = makeErrorLogger(type, path, abortOnFail);

		const validActionTypes = ['add', 'modify'];
		if (!validActionTypes.includes(type)) {
			return failure(`Invalid action type "${ type }"`);
		}

		if (typeof path !== 'string' || path.length === 0) {
			return failure(`Invalid path "${ path }"`);
		}

		return true;
	}

	function makeErrorLogger(type, path, abortOnFail) {
		return function (error) {
			if (abortOnFail !== false) {
				abort = true;
			}
			return { type: type, path: path, error: error };
		};
	}

	return {
		runGeneratorActions: runGeneratorActions,
		runGeneratorPrompts: runGeneratorPrompts
	};
};

var _co = require('co');

var _co2 = _interopRequireDefault(_co);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _colors = require('colors');

var _colors2 = _interopRequireDefault(_colors);

var _fsPromiseProxy = require('./fs-promise-proxy');

var fspp = _interopRequireWildcard(_fsPromiseProxy);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }